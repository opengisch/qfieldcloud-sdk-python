#!/bin/env python3

import collections
import json
from enum import Enum

import click

from qfieldcloud_sdk import sdk

QFIELDCLOUD_DEFAULT_URL = "https://app.qfield.cloud/api/v1/"


class OutputFormat(Enum):
    HUMAN = "HUMAN"
    JSON = "JSON"


def print_json(data):
    print(json.dumps(data, sort_keys=True, indent=2))


class OrderedGroup(click.Group):
    def __init__(self, name=None, commands=None, **attrs):
        super(OrderedGroup, self).__init__(name, commands, **attrs)
        self.commands = commands or collections.OrderedDict()

    def __call__(self, *args, **kwargs):
        try:
            return self.main(*args, **kwargs)
        except sdk.QfcRequestException as err:
            click.echo(str(err))
        except sdk.QfcException as err:
            click.echo(str(err))

    def list_commands(self, ctx):
        return self.commands


@click.group(cls=OrderedGroup)
@click.option(
    "-U",
    "--url",
    envvar="QFIELDCLOUD_URL",
    default=QFIELDCLOUD_DEFAULT_URL,
    type=str,
    help=f"URL to the QFieldCloud API endpoint. If not passed, gets the value from QFIELDCLOUD_URL environment variable. Default: {QFIELDCLOUD_DEFAULT_URL}",
)
@click.option(
    "-u",
    "--username",
    envvar="QFIELDCLOUD_USERNAME",
    type=str,
    help="Username or email.",
)
@click.option("-p", "--password", envvar="QFIELDCLOUD_PASSWORD", type=str)
@click.option(
    "-t", "--token", envvar="QFIELDCLOUD_TOKEN", type=str, help="Session token."
)
@click.option(
    "--json/--human",
    "format_json",
    help="Output the result as newline formatted json. Default: False",
)
@click.option(
    "--verify-ssl/--no-verify-ssl",
    "verify_ssl",
    default=True,
    help="Verify SSL. Default: True",
)
@click.pass_context
def cli(
    ctx: click.Context,
    url: str,
    username: str,
    password: str,
    token: str,
    format_json: bool,
    verify_ssl: bool,
):
    """The official QFieldCloud CLI tool.

    Examples:

    qfieldcloud-cli login user pass

    qfieldcloud-cli -u user -p pass -U https://localhost/api/v1/ list-projects
    """
    ctx.ensure_object(dict)
    ctx.obj["client"] = sdk.Client(url, verify_ssl, token=token)
    ctx.obj["format_json"] = format_json

    if username or password:
        ctx.obj["client"].login(username, password)


@cli.command()
@click.argument("username", envvar="QFIELDCLOUD_USERNAME", required=True)
@click.argument("password", envvar="QFIELDCLOUD_PASSWORD", required=True)
@click.pass_context
def login(ctx, username, password) -> None:
    """Login to QFieldCloud."""
    user_data = ctx.obj["client"].login(username, password)

    if ctx.obj["format_json"]:
        print_json(user_data)
    else:
        print(f'Welcome to QFieldCloud, {user_data["username"]}.')
        print(
            "QFieldCloud has generated a secret token to identify you. "
            "Put the token in your in the environment using the following code, "
            "so you do not need to write your username and password again:"
        )
        print(f'export QFIELDCLOUD_TOKEN="{user_data["token"]}"')


@cli.command()
@click.pass_context
def logout(ctx):
    """Logout and expire the token."""

    payload = ctx.obj["client"].logout()

    if ctx.obj["format_json"]:
        print_json(payload)
    else:
        print(payload["detail"])


@cli.command()
@click.option(
    "--include-public/--no-public",
    default=False,
    help="Includes the public project in the list. Default: False",
)
@click.pass_context
def list_projects(ctx, include_public):
    """List QFieldCloud projects."""
    projects = ctx.obj["client"].list_projects(
        include_public=include_public,
    )

    if ctx.obj["format_json"]:
        print_json(projects)
    else:
        if projects:
            print("Projects:")
            for project in projects:
                print(f'{project["id"]}\t{project["owner"]}/{project["name"]}')
        else:
            print("User does not have any projects yet.")


@cli.command()
@click.argument("project_id")
@click.pass_context
def list_files(ctx, project_id):
    """List QFieldCloud project files."""
    files = ctx.obj["client"].list_files(project_id)

    if ctx.obj["format_json"]:
        print_json(files)
    else:
        if files:
            print(f'Files for project "{project_id}":')
            for file in files:
                print(f'{file["last_modified"]}\t{file["name"]}')
        else:
            print(f'No files within project "{project_id}"')


@cli.command()
@click.argument("name")
@click.option("--owner", "owner", help="Owner of the project. If omitted, the current user is the owner.")
@click.option("--description", "description", help="Description of the project.")
@click.option(
    "--is-public/--is-private", "is_public", help="Mark the project as public."
)
@click.pass_context
def create_project(ctx, name, owner, description, is_public):
    """Creates a new empty QFieldCloud project."""
    project = ctx.obj["client"].create_project(
        name, owner, description=description, is_public=is_public
    )

    if ctx.obj["format_json"]:
        print_json(project)
    else:
        print(
            f'Created project "{project["owner"]}/{project["name"]}" with project id "{project["id"]}".'
        )


@cli.command()
@click.argument("project_id")
@click.argument("project_path")
@click.option(
    "--filter",
    "filter_glob",
    help="Do not upload the whole project, but only the files which match the glob.",
)
@click.option(
    "--exit-on-error/--no-exit-on-error",
    help="If any project file download fails stop downloading the rest. Default: False",
)
@click.pass_context
def upload_files(ctx, project_id, project_path, filter_glob, exit_on_error):
    """Upload files to a QFieldCloud project."""

    def upload_cb(file):
        if ctx.obj["format_json"]:
            return

        if file.get("error"):
            print(f'File "{file["name"]}" failed to upload.')
        else:
            print(f'File "{file["name"]}" has been uploaded successfully.')

    files = ctx.obj["client"].upload_files(
        project_id, project_path, filter_glob, exit_on_error, cb=upload_cb
    )

    if ctx.obj["format_json"]:
        print_json(files)
    else:
        if files:
            print(f"Upload finished after uploading {len(files)}.")
        else:
            print("Nothing to upload.")


@cli.command()
@click.argument("project_id")
@click.argument("local_dir")
@click.option(
    "--filter",
    "filter_glob",
    help="Do not download the whole project, but only the files which match the glob.",
)
@click.option(
    "--exit-on-error/--no-exit-on-error",
    help="If any project file downloads fails stop downloading the rest. Default: False",
)
@click.pass_context
def download_files(ctx, project_id, local_dir, filter_glob, exit_on_error):
    """Download QFieldCloud project files."""

    def downloaded_cb(file):
        if ctx.obj["format_json"]:
            return

        if file.get("error"):
            print(f'File "{file["name"]}" failed to download.')
        else:
            print(f'File "{file["name"]}" has been downloaded successfully.')

    files = ctx.obj["client"].download_files(
        project_id, local_dir, filter_glob, exit_on_error, finished_cb=downloaded_cb
    )

    if ctx.obj["format_json"]:
        print_json(files)
    else:
        if files:
            print(f"Download status of files in project {project_id}:")
            for file in files:
                print(f'{file["status"].value}\t{file["name"]}')
        else:
            if filter_glob:
                print(
                    f"No files to download for project {project_id} at {filter_glob}"
                )
            else:
                print(f"No files to download for project {project_id}")


@cli.command()
@click.argument("project_id")
@click.pass_context
def package_trigger(ctx, project_id):
    """Initiate project packaging for QField."""
    status = ctx.obj["client"].package_trigger(project_id)

    if ctx.obj["format_json"]:
        print_json(status)
    else:
        print(f"Packaging triggered for {project_id}.")


@cli.command()
@click.argument("project_id")
@click.pass_context
def package_status(ctx, project_id):
    """Check project packaging status."""
    status = ctx.obj["client"].package_status(project_id)

    if ctx.obj["format_json"]:
        print_json(status)
    else:
        print(f'Packaging status for {project_id}: {status["status"]}')
        if status["layers"] is None:
            if status["status"] == "STATUS_ERROR":
                print("Packaging have never been triggered on this project. Please run:")
                print(f"qfieldcloud-cli package-trigger {project_id}")
            return

        for layer_obj in status["layers"].values():
            if layer_obj["valid"]:
                print(
                    f'Layer "{layer_obj["name"]}" is valid, finished with status: {layer_obj["status"]}'
                )
            else:
                print(
                    f'Invalid layer "{layer_obj["name"]}", status: {layer_obj["status"]}'
                )


@cli.command()
@click.argument("project_id")
@click.argument("local_dir")
@click.option(
    "--filter",
    "filter_glob",
    help="Do not download the whole packaged project, but only the files which match the glob.",
)
@click.option(
    "--exit-on-error/--no-exit-on-error",
    help="If any packaged file downloads fails stop downloading the rest. Default: False",
)
@click.pass_context
def package_download(ctx, project_id, local_dir, filter_glob, exit_on_error):
    """Download packaged QFieldCloud project files."""

    def downloaded_cb(file):
        if ctx.obj["format_json"]:
            return

        if file.get("error"):
            print(f'Packaged file "{file["name"]}" failed to download.')
        else:
            print(f'Packaged file "{file["name"]}" has been downloaded successfully.')

    files = ctx.obj["client"].package_download(
        project_id, local_dir, filter_glob, exit_on_error, finished_cb=downloaded_cb
    )

    if ctx.obj["format_json"]:
        print_json(files)
    else:
        if files:
            print(f"Download status of packaged files in project {project_id}:")
            for file in files:
                print(f'{file["status"].value}\t{file["name"]}')
        else:
            if filter_glob:
                print(
                    f"No packaged files to download for project {project_id} at {filter_glob}"
                )
            else:
                print(f"No packaged files to download for project {project_id}")


if __name__ == "__main__":
    cli()
